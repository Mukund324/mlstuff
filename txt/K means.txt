

X = [
    [5.9, 3.2],
    [4.6, 2.9],
    [6.2, 2.8],
    [4.7, 3.2],
    [5.5, 4.2],
    [5.0, 3.0],
    [4.9, 3.1],
    [6.7, 3.1],
    [5.1, 3.8],
    [6.0, 3.0]
]

/
centroids = [
    [6.2, 3.2], [6.6, 3.7], [6.5, 3.0]]

clusters= {}

/
def euc_dist(x1, x2, y1, y2):
    '''
    Returns the euclidean distance between the given points.
    '''
    res = (((x2 - x1) ** 2) + ((y2 - y1) ** 2)) ** 0.5
    return res
/


def k_means(X, centroids, clusters, k=4):
    '''
    Assigns each point in X to a centroid in centroids populating the clusters dictionary.
    '''
    for i in range(k):
        clusters[i] = []

    for i, _ in enumerate(X):
        dist = []

        for j in range(k):
            dist.append(euc_dist(centroids[j][0], X[i][0], centroids[j][1], X[i][1]))

        centroid_ind = dist.index(min(dist))
        clusters[centroid_ind].append(X[i])

    return clusters

/

def new_centroids(X, centroids, clusters, k=4):
    '''
    Forms new centroids using average of all points in the cluster.
    '''
    for i in range(k):
        x_sum = sum([n[0] for n in clusters[i]])
        y_sum = sum([n[1] for n in clusters[i]])

        centroids[i] = [round(x_sum / len(clusters[i]), 3), round(y_sum / len(clusters[i]), 3)]

    return centroids
/
for i in range(6):
    clusters = k_means(X, centroids=centroids, clusters=clusters, k=3)
    centroids = new_centroids(X, centroids=centroids, clusters=clusters, k=3)

    print(f"Centroids during iteration {i+1}: {centroids}")
    if i == 0:
        print(f"Centre of the first cluster after 1 iteration: {centroids[0]}\n")
    elif i == 1:
        print(f"Centre of the second cluster after 2 iterations: {centroids[1]}\n")
/

print(f"Centre of the third cluster after it converges: {centroids[2]}")

/
print("Observing the values found in the previous iterations, the number of iterations required is 3")

/
